{"pages":[],"posts":[{"title":"Proxy에 대하여","text":"Proxy다른사람을 대신/대리 하여 무엇인가를 하는 것 (중개)을 뜻한다 이런 의미에서 프록시 서버란 다른 서버가 하는 일을 대신하여 처리해주는 서버를 지칭하는 말이다 캐시/보안/트래픽 분산 등 여러 장점을 가질 수 있다. 프록시의 종류로는 포워드 프록시(Forward Proxy)와 리버스 프록시(Reverse Proxy)가 있는데,네트워크 구조의 어떠한 위치에서 역할을 수행하는지에 따라 이름이 바뀐다. 네트워크 통신 구조를 크게 다음과 같이 정의하겠다. Client(사용자) - Internet(인터넷) - Server(서버)포워드 프록시(Forward Proxy)포워드 프록시는, 사용자와 인터넷 사이에 위치해 프록시의 역할을 하는 컴퓨터를 Forward Proxy라고 한다. 특징캐시 사용자가 요청한 내용의 데이터를 저장하고 있다가. 이후에 똑같은 요청이 오면, 저장하고 있던 값을 응답으로 주는 것 전송 시간 절약 불필요한 외부 전송이 필요 없음 외부 요청 감소 -&gt; 네트워크의 병목현상 방지 익명성 사용자가 보낸 요청을 감춘다 사용자가 서버로 요청을 할 때, 프록시 서버에 대신해서 요청을 하고 응답을 받아달라고 하는 것이다 그렇기 때문에 서버는 Proxy의 존재는 알지라도, 실질적으로 데이터를 요청하는 사용자의 정보를 알지 못한다. 이러한 이유로 해커들이 자신들의 존재를 숨기기 위해 프록시서버를 이용하기도 한다 리버스 프록시(Reverse Proxy)리버스 프록시는, 서버와 인터넷 사이에 위치해 프록시의 역할을 하는 컴퓨터를 Reverse Proxy라고 한다. 특징캐시Forwrad Proxy의 캐시와 동일한 기능을 한다. 사용자가 요청한 데이터를 저장하고 있다가. 실질적인 데이터를 가진 서버에게 요청하지 않고, 저장하고 있던 값을 응답합니다. 보안Forward Proxy와 다르게 서버의 정보를 감춥니다. 사용자는 서버에 요청을 한다고 생각하지만, 실제로는 Reverse Proxy가 서버의 역할을 ‘대신’해 사용자의 요청을 받고, 받은 요청의 결과를 사용자에게 응답으로 전달합니다 즉, 사용자는 실질적인 서버의 역할을 하는 컴퓨터의 정보는 알지 못하고, 오로지 Proxy Server의 정보만 알게됩니다. 로드밸런싱(Load Balancing; 부하 분산)로드밸런스 Wiki 둘 이상의 서버 컴퓨터의 앞에서 사용자의 요청을 받아, 서버의 상태에 맞게 요청을 분산시켜주는 역할을 뜻합니다. 대부분 서버의 상태에 따라 최상의 상태인 서버로 요청을 전달해주기 때문에,로드밸런싱이 적용된 서비싀는사용자가 몰려도 균일한 서비스를 받을 수 있다는 특징이 있습니다. 대표적인 로드밸런싱 알고리즘으로 라운드로빈(Round Robin), 최소 연결(Least Connection), 최소 응답시간(Leas Response Time) 방식이 있습니다. 참조(Reference)우아한Tech 유튜브 채널 제이미님의 발표","link":"/2020/11/02/About-Proxy/"},{"title":"Spring IoC에 대하여","text":"Spring 제어의 역전(IoC; Iversion of Control) **객체에 대한 제어권이 개발자로부터 컨테이너(Spring Container)**에 넘어가면서 객체의 생성부터 생명주기 관리까지의 모든 것을 컨테이너가 맡아서 하게되는 것 일반적인 개발방식에서, 모든 인스턴스에 대한 권한은 개발하며 코드상에 객체의 생성 삭제 등을 작성하는 개발자의 몫이었음 ==&gt; 객체의 제어 권한이 개발자에게 있음 의존성컨테이너가 인터페이스를 통해 의존성이 있는 클래스의 객체를 생성하고생성한 객체를 이를 사용하려는 클래스에 주입을 해준다여기서 의존성 주입(DI; Dependency Injection)이 등장한다 일반적인 형태의 의존성 주입1234567891011class A{ // A에서 B클래스의 객체를 사용한다 // 이렇게 어떠한 클래스에서 다른 클래스의 객체를 사용할때 의존성 관계에 있다고 하고 // 이 경우 A클래스가 B클래스에 의존성이 있다고 한다 private B bInstance; // Constructor A(){ bInstance = new B(); }} IoC에 의한 의존성 주입12345678910class A{ // 클래스내에서 직접 객체를 생성하지 않는다 private B bInstance; // 생성자를 통해서 외부의 누군가가 파라미터로 주입해준 객체를 이용한다 // 외부에서 설정된(Configured) 객체를 집어넣어주는 것이다 A(B b){ bInstance = b; }} 스프링 컨테이너는 처음 구동시 클래스의 객체를 생성해두고해당 객체(ex. @Autowired 어노테이션이 선언된 인스턴스 객체 )를 사용할 때, 인터페이스로 이를 제공해 인터페이스 기반의 컴포넌트화를 구현한다 Spring 컨테이너가 실행하는 인스턴스화는 기본적으로 1회만 실행하여 필요한곳에 사용한다. 즉, 기본적으로 Singleton으로 생성을 함 @Autowired와 @Component Sppring 컨테이너는 첫 구동시에 Component어노테이션이 선언되어있는 클래스의 객체를 생성해둔다 @Component어노테이션을 확장한 3가지의 어노테이션이 존재한다@Controller@Service@Repository","link":"/2020/05/15/About-Spring-IoC/"},{"title":"Floyd-Warshall Algorithm, 플로이드-와샬","text":"요약 A지점에서 B지점으로 가는 경로가 존재하고, A-&gt;K &amp;&amp; K-&gt;B 가 가능한 K지점이 존재할 때, 둘 중 적은 비용으로 이동이 가능한 경로를 찾는 알고리즘 1234567891011121314151617181920212223242526272829303132333435363738public class Floyd_Warshall{ static int INF = Integer.MaxValue; static int N; static int[][] map; public static void main(String[] args){ init(); } public static void flo_war(){ for(int k = 0; k &lt; N; k++){ for(int i = 0; i &lt; N; i++){ for(int j = 0; j &lt; N; j++){ if( i != j ){ // map[i][j] 는 현재까지 찾은 i에서 j로가는 가장 적은 비용 map[i][j] = Integer.min(map[i][j], map[i][k] + map[j][k]); } } } } } public static void init(){ Scanner sc = new Scanner(System.in); N = sc.nextInt(); map = new int[N][N]; for(int i = 0; i &lt; N; i++){ for(int j = 0; j &lt; M; j++){ map[i][j] = sc.nextInt(); // 자기 자신에게 돌아오는 길을 없음을 나타낸다 if(map[i][j] == 0) map[i][j] = INF; if(i==j) map[i][j] = 0; } } }} 설명다중 출발점에서 다중 도착점으로 가는 최소시간(거리)를 구하는 알고리즘으로O(n^3)의 시간복잡도를 갖는다위와 같은 시간복잡도를 갖는 이유는 출발점, 도착점에 대해 갈 수 있는 모든 다른점에 대해 최솟값을 찾기 때문이다그렇기 때문에, 알고리즘의 작동만 이해한다면 매우 간단한 수준의 알고리즘이다.","link":"/2020/06/28/Floyd-Warshall-Algorithm/"},{"title":"Spring Bean","text":"빈 (Bean) Spring IoC 컨테이너가 관리하는 자바 객체를 빈(Bean)이라 한다. 개발자가 new 연산자로 생성하는 객체는 빈이라고 할 수 없다. Spring IoC 컨테이너에 빈을 등록하는 법방법은 다양하지만 크게 두가지 방법이 있다. Component Scanning 빈 설정파일에 직접 빈을 등록 Component Scan@ComponentScan 어노테이션과 @Component 어노테이션을 사용해서 빈을 등록하는 방법 SpringBoot 프로젝트 생성시 기본적으로 만들어지는 xxxApplication 클래스에 선언된 @SpringBootApplication 어노테이션을 보면, @ComponentScan어노테이션이 내부에 선언되어 있다.그렇기 때문에, application 실행 시 이 클래스가 있는 패키지와 모든 하위패키지를 검사해 @Component 어노테이션을 사용하는 클래스를 찾고, 해당 클래스의 객체를 생성해 컨테이너의 빈에 등록한다 @ComponentScan어느 지점부터 컴포넌트를 찾을지 알려주는 역할해당 어노테이션이 선언되어있는 클래스의 패키지에서부터 모든 하위 패키지의 클래스를 찾아보며 @Component 또는 이를 사용하는 다른 어토네이션이 붙은 클래스를 찾는다 @Component어노테이션을 사용하는 어노테이션 @Controller @Service @Repository @Component찾아서 빈으로 등록할 클래스를 의미 1234@Componentpublic class MemberController{ // do something ...} 빈 설정파일에 직접 빈을 등록빈 설정파일은 xml과 자바 설정파일로 작성할 수 있으며, 자바 설정파일을 많이 사용한다 자바 설정파일은 자바 클래스를 생성해 작성이 가능하며, xxxCongifuration과 같이 명명하고, 클래스에 @Configuration 어노테이션을 선언 한 다음, 내부에 @Bean 어노테이션을 사용해 빈(Bean)을 정의한다 12345678@Configurationpublic class MemberConfiguration { @Bean public MemberController memberController(){ // 리턴되는 객체가 IoC 컨테이너에 빈으로 등록된다 return new MemberController(); }} @Configuration 어노테이션 또한 @Component를 사용하기 때문에 @ComponentScan의 스캔 대상이 되고, 빈 설정파일이 읽힐 때 그안에 정의한 빈들이 IoC컨테이너에 등록이 된다","link":"/2020/06/16/Spring-Bean/"},{"title":"JWT의 사용과 인증","text":"구조JWT는 점 (.) 을 기준으로 크게 세 부분으로 나뉘어 있다. header payload JWT의 권한claims를 담고있다. 따라서, 디코드하면 claims를 담고있는 json객체를 확인할 수 있다. signature : 토큰의 무결성을 검증하기 위한 시그니쳐 해시(Signature hash) 권한 claims토큰을 이용한 인증을 할 때, 인증에 필요한 정보들을 담고있다. 일반적으로 사용자에 대한 정보, 접근 권한, 만료 시간 등을 담고있다. 이 JWT토큰은 개발자만이 알고 있는 비밀 키(Secret Key)로 서명되어 있으므로, 토큰에 담겨있는 정보(claims)를 암묵적으로 신뢰가 가능합니다. 자바에서 JWT의 생성과 검증JSON Web Token의 생성과 검증까지 모든 기능을 제공하는 JJWT라이브러리를 사용한다. 생성1234567891011121314151617181920212223@Servicepublic class JwtServiceImpl implements IJwtService{ // 2시간의 만료시간 (2 * 60 * 60 * 1000) @VAlue(\"${auth.jwt.expiretime}\") static final long expireTime; @Value(\"${auth.jwt.key}\") static final MyTokenSecretKey; @Override public String getJwtToken(){ return Jwts.builder() .setExpiration(new Date(System.currentTimeMills)+expireTime) // 생성시점 + 설정 시간 이후에 만료가 된다. .claims(\"name\", \"User Name\") // 토큰에 담을 정보들을 설정 .claims(\"scope\", \"user\") .signWith(SignatureAlgorithm.HS256, getByteArray(MyTokenSecretKey)) .compact(); } private byte[] getByteArray(String str){ return str.getBytes(\"UTF-8\"); }} OAth를 따르기 위해 2개의 토큰을 사용한다면, 각각의 토큰을 발급하기 위한 SecretKey를 다르게 하여야 한다. jwt를 생성하고 나서 Authorization헤더에 담아 클라이언트로 보내게 되며, 클라이언트는 인증이 필요할 때 서버로부터 받은 jwt토큰을 담 Authorization헤더에 담아 서버에 데이터를 요청하게된다. 검증위에서 생성한 JWT를 검증하는 예제입니다. 12345678910111213141516171819202122232425public JwtServiceImple implements IJwtService{ // ... @Override public boolean isValidationToken(String token){ try{ // JWT를 파싱하여 검증한다 Jws&lt;Claims&gt; claims = Jwts.parser() .setSigningKey(getByteArray(MyTokenSecretKey)) // 위에서 작성한 메서드 .parseClaimsJws(token); String scope = claims.getBody().get(\"scope\"); // scope 검증 return true; }catch(SignatureException e){ // JWT의 서명이 맞지 않을 때 e.printStackTrace(); }catch(ExpiredJwtException){ // JWT의 시간이 만료되었을 때 e.printStackTrace(); }catch(Exception e){ e.printStackTrace(); } return false; }} 만약 서명에 오류가 있다면, parseClaimsJws()에서 SignatureException이 발생합니다 파싱에 성공하면 claim들을 가져와서 값들을 검사할 수 있습니다. ReferenceOut of Bedlam 님의 Mediam JWT 라이브러리와 해당 저장소를 모아둔 사이트","link":"/2020/03/15/Spring-Jwt/"},{"title":"Spring Properties 관리","text":"spring boot에서 properties를 읽는 방법 @Value 어노테이션 이용 Enviroment 클래스 이용 Spring doc에서 properties 적용 우선순위 file:./custom-config classpath:custom-config file:./config/ file:./ classpath:/config/ classpath:/ jar command에서 spring boot 외부의 properties 파일을 불러오는 방법1. spring.config.name1$ java -jar app.jar --spring.config.name=myproject myproject 부분에는 spring project에서 resource에 있는 application.properties의 이름을 적어주면 된다 만약 application-dev.properties와 application-deploy.properties 두개의 설정파일이 있다면 개발 시에는 application-dev 를, 배포시에는 application-deploy 를 적어주면 된다 2. spring.config.location1$ java -jar app.jar --spring.config.location=classpath:/default.properties,classpath:/overried.properties","link":"/2020/03/15/Spring-properties-managing/"},{"title":"Vue EventBus 사용","text":"EventBus 컴포넌트 생성EventBus.js로 Event Bus를 담당할 컴포넌트를 생성한다 123456// @/utils/EventBus.jsimport Vue from 'vue';const eventbus = new Vue();export default eventbus; 이렇게 파일을 생성하면 기본적인 준비는 끝 발행$emit() 을 이용해 이벤트를 발행할 수 있다. 123456789101112131415161718// 이벤트를 발행할 Vue 컴포넌트// Emit.vue&lt;template&gt; &lt;Button @click=&quot;emitEvent&quot;&gt; 이벤트 발행 &lt;/Button&gt;&lt;/template&gt;&lt;script&gt; import Eventbus from '@/utils/EventBus' export default{ methods:{ emitEvent(){ // 발행할 이벤트의 이름과 함께, 넘겨주소 싶다면 변수를 추가해줄 수 있다. Eventbus.$emit('myEvent', '변수를 넘겨줄께요'); } } }&lt;/script&gt; 위의 코드에서는 myEvent라는 이벤트 이름과 함께, ‘변수를 넘겨줄께요’라는 String 변수를 인자로 이벤트를 발행하였다 구독이벤트의 구독은 $on 을 통해 이벤트 구독할 수 있다. 더해서, vue의 template에서 @myEvent 처럼, 클릭이벤트를 등록하듯이 이벤트를 등록할 수 있다. 123456789101112131415161718192021222324// 이벤트를 구독할 Vue 컴포넌트// Receive.vue&lt;template&gt; &lt;div&gt; &lt;h1&gt; {{receive}} &lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Eventbus from '@/utils/EventBus' export default{ data(){ return { receive:'' } }, created(){ EventBus.$on('myEvent', (arg)=&gt;{ this.receive = arg; }); } }&lt;/script&gt; Emit.vue 에서 ‘이벤트 발행’ 버튼을 클릭해 이벤트를 발행한 후, 이벤트를 구독하는 컴포넌트인 Receive.vue 컴포넌트를 실행하게 되면, created hook에서 이벤트를 구독하고 receive 변수에 넘겨주었던 String 인자가 할당되어, 화면에 표시된다 삭제이벤트의 삭제는 $off를 이용한다. 위의 예제에서, 컴포넌트가 삭제될 때 발행한 이벤트를 삭제하고 싶다면 12345&lt;script&gt; beforeDestory(){ EventBus.$off('myEvent'); }&lt;/script&gt; 이벤트가 계속해서 남아있는게 싫다면, 이벤트를 구독 후 삭제한다 1234567891011121314&lt;script&gt; //... methods:{ eventHandler(){ // 이벤트 구독 EventBus.$on('myEvent', (arg)=&gt;{ this.receive = arg; }); // 이벤트 삭제 EventBus.$off('myEvent'); } } //...&lt;/script&gt;","link":"/2020/08/10/Vue-eventbus/"},{"title":"intellij에서 실행 옵션 설정하기","text":"intellij 상에서 spring 프로젝트를 실행할 때, 따로 옵션을 설정해주어야 할 때가 있다. ex) 개발 시 설정파일을 바꾸어주어야 할 때 오른쪽 상단의 실행 버튼 왼쪽에 드롭다운 박스를 눌러 Edit Configuration 을 눌러준다 spring boot 섹션에서 밑에있는 Override parameters에 설정해주고자 하는 옵션의 이름과 값을 적어주면 끝! 위의 이미지와 같이 옵션을 주었을 때, 1$ java -jar app.jar --spring.config.name=application-dev 을 실행한것과 같다","link":"/2020/11/02/add-exec-env-intellij/"},{"title":"이진탐색","text":"개요분할 정복 (devide and conquer) 기법을 이용한 탐색방법정렬이 되어있어야 탐색이 가능하다탐색시간은 O (lg n) 시간을 갖는다 이진 탐색 (Binary Search)소스코드123456789101112131415161718// 타겟의 값이 배열 내에 있으면 해당 위치를// 타겟의 값이 없으면, 타겟이 들어갈 위치값을 리턴public static int binary_search(int target) { int start = 0, end = arr.length - 1; while (start &lt;= end) { int mid = (start + end) / 2; if (arr[mid] == target) { return mid; } else if (arr[mid] &lt; target) { start = mid + 1; } else { end = mid - 1; } } return end;} 출력 결과 하한선 (Lower Bound)소스코드1234567891011121314public static int lower_bound(int target){ int start =0, end = arr.length-1; while(start &lt; end){ int mid = (start+end)/2; if(arr[mid] &lt; target){ start = mid+1; }else{ end = mid } } return end;} 출력 결과 상한선 (Upper Bound)소스코드1234567891011121314public static int upper_bound(int target){ int start = 0, end= arr.length; while(start &lt; end){ int mid = (start + end)/2; if(arr[mid] &lt;= target){ start= mid+1; }else{ end = mid; } } return end;} 출력결과","link":"/2020/03/17/binary-search/"},{"title":"combination","text":"조합 (Combination)12345678910111213141516171819202122// 고르고 안고르고의 경우의 수가 존재 public static void combi(int[] sel, int[] arr, int idx, int sidx) { if (sidx == r) { // n개중에 r개를 뽑음 for (int i = 0; i &lt; sidx; i++) { System.out.print(sel[i] + \" \"); } System.out.println(); combicnt++; return; } if (arr.length == idx) { return; } sel[sidx] = arr[idx]; // 뽑았을때 combi(sel, arr, idx + 1, sidx + 1); // 뽑지않았을때 combi(sel, arr, idx + 1, sidx); } 순열 (Permutation)123456789101112131415161718192021// 모든 시행에서 선택하지 않은것이 있으면 선택&amp;체크 후 넘어간다 public static void perm(int[] sel, int[] arr, int idx, boolean[] visit) { if (r == idx) { // condition of terminate for (int i = 0; i &lt; sel.length; i++) { System.out.print(sel[i] + \" \"); } System.out.println(); permcnt++; return; } for (int i = 0; i &lt; arr.length; i++) { if (!visit[i]) { visit[i] = true; sel[idx] = arr[i]; perm(sel, arr, idx + 1, visit); visit[i] = false; } } } 순열 - 스왑이용 (Permutation)12345678910111213141516171819202122232425// 자기자신의 위치와 다른것들과의 위치를 한번씩 모두 바꾸면서 진행 public static void perm_swap(int[] arr, int depth) { if (depth == r) { for (int i = 0; i &lt; depth; i++) { System.out.print(arr[i] + \" \"); } System.out.println(); perm_swapcnt++; return; } for (int i = depth; i &lt; arr.length; i++) { swap(arr, depth, i); perm_swap(arr, depth + 1); swap(arr, depth, i); } } // 스왑함수 // 배열과 위치를 받아 두 위치의 원소의 위치를 교환 public static void swap(int[] arr, int idx, int idx2) { int tmp = arr[idx]; arr[idx] = arr[idx2]; arr[idx2] = tmp; }","link":"/2020/02/15/combination/"},{"title":"Dockerfile과 Docker-compose","text":"Dockerfile from docker hub에 있는 이미지를 가져와 베이스로 사용한다 alpine이라는 정말 필요한 최소한의 기능만 있는 이미지 또한 있어, 이미지 용량을 매우 많이 줄일 수 있다. arg Dockerfile로 이미지를 빌드할때만 사용할 변수를 선언한다 빌드시점에만 사용 docker build시에 –build-arg 옵션을 이용해 오버라이딩 가능 env 환경 변수 지정 $변수 or ${변수} 형태로 표현 docker run 시에 -e 옵션을 이용해 오버라이딩 가능 workdir 컨테이너 내에서 사용할 Working Directory를 지정한다 orkdir 밑으로 오는 명령어는 workdir로 지정한 경로가 기본경로가 된다 copy copy src dest 형태 src의 디렉터리 및 파일을 컨테이너의 경로 or workdir 기준 상대경로로 복사한다. 파일을 그대로 가져오고, 권한도 그대로 ex) copy /src /src ==&gt; dockerfile이 있는 곳의 src디렉토리를 컨테이너 내부의 src디렉토리로 복사 add add src dest src의 디렉터리 및 파일을 컨테이너의 경로 or workdir 기준 상대경로로 복사한다. 압축파일인 경우, 압축을 해제 OS에 따라 압축해제 여부 파일은 소유 root:root 와 기존 권한을 가짐 URL은 소유 root:root와 600 권한을 가짐 volume 컨테이너 내부의 디렉토리를 호스트의 디렉토리와 링크하기 위한 커맨드 보통 DB의 테이블데이터나, 프로그램 가동시 생성되는 로그파일들이 저장되어 있는 디렉토리를 링크한다 expose 외부로 노출할 포트를 지정한다 as run 터미널 명령어를 실행할 수 있음ex) 예시로 echo “hello world” 새로운 레이어를 생성하거나, 생성된 layer 위에서 command를 실행- pacakge를 설치하는 명령어룰 주로 사용한다 cmd 컨테이너가 처음 시작될때 실행 Dockerfile에서 한번만 사용 가능 마지막 CMD만 사용된다 CMD [“실행파일”,”매개 변수”,”매개 변수..”] docker run [IMAGE] [COMMAND] 에서 COMMAND를 넣으면 CMD가 무시됨 entrypoint 컨테이너가 처음 시작될때 실행 CMD와 같이 있으면, CMD는 매개변수, ENTRYPOINT는 실행파일 역할 docker run –entrypoint=”[COMMAND] [IMAGE]”를 사용해 무시 가능 Dockerfile12345678910111213141516FROM node:lts-alpine as build-stageWORKDIR /appCOPY package*.json ./RUN npm install --productionCOPY . .RUN npm run buildFROM nginx:stable-alpine as production-stageCOPY --from=build-stage /app/dist /usr/share/nginx/htmlEXPOSE 80CMD [\"nginx\",\"-g\",\"daemon off;\"] ARG와 ENV의 차이ADD와 COPY의 차이CMD와 ENTRYPOINT의 차이 Docker-compose개요 문서작성 한번으로 여러개의 도커 컨테이너를 생성하고 실행 docker-compose.yml 파일을 작성해 이미지 빌드 및 실행 빌드 및 실행 docker-compose build : docker-compose.yml 파일을 읽어 내용대로 도커 이미지를 빌드 docker-compose up : docker-compose.yml 파일을 읽어 내용대로 이미지를 생성하고 실행 구성 version : docker-compose의 버전을 지정 serveices : 여러개의 이미지를 빌드하거나, dockerfile을 이용해 빌드가 가능하다 Docker-compose.yml1234567891011121314151617181920212223242526272829303132333435version: \"3\"services: # 만들어진 Dockerfile을 이용해서 이미지를 빌드하고 실행 front: build: # Dockerfile을 이용한 빌드시 기준경로가 되는 디렉터리 context: ./front-sk dockerfile: Dockerfile # 컨테이너의 이름을 day4_front로 지정 container_name: day4_front ports: - \"80:80\" # mysql:5.7.29 이미지를 이용해 Database를 생성하고 시작 db: image: mysql:5.7.29 restart: always # 이미지가 expose하는 3306포트를 10101포트로 매핑 ports: - \"10101:3306\" container_name: day4_db # docker run -e 옵션을 지정하는 방법 environment: - MYSQL_ROOT_PASSWORD=root - MYSQL_DATABASE=ssafy # command명령어를 통해 추가 옵션을 지정할 수 있다 command: ['mysqld','--character-set-server=utf8mb4','--collation-server=utf8mb4_unicode_ci'] back: build: context: ./back-sk dockerfile: Dockerfile container_name: day4_back ports: - \"10001:8080\" ETC알파인 리눅스 (Alpine Linux)개요 가볍고 간단하고 보안성을 목적으로 개발한 리눅스 배포판 apk 패키지 관리자 Docker이미지의 경우 5MB의 작은 용량을 가짐 출처 docker-compose 공식 문서 : https://docs.docker.com/compose/compose-file/compose-versioning/ docker hub : https://hub.docker.com/","link":"/2020/04/22/docker-basic/"},{"title":"JAVA 해싱 알고리즘 사용하기","text":"해싱알고리즘해싱알고리즘은 해시 함수를 기반으로 하는 암호화 알고리즘 중 하나입니다. 해싱 알고리즘이 암호화에 사용되는 이유는 해시함수의 특성에서 비롯됩니다. 해시함수 구현Java에서는 기본적으로 해시 알고리즘을 사용하는 라이브러리를 제공하고 있습니다 java.security.MessageDigest에 해당 라이브러리가 존재하며, 이를 이용하여 문자열에 해시 처리가 가능합니다. MessageDigest의 문서 MessageDigest에서는 MD5, SHA-1, SHA-256을 사용하고 있으며, SHA-1의 사용은 권장하지 않으므로 12345678/*** 가장 기본적인 형태의 해시함수 구현*/public byte[] hasing(String src) throws NoSuchAlgorithmException { MessageDigest md = MessageDigest.getInstance(\"SHA-256\"); // 해시 알고리즘에서 사용할 알고리즘의 종류를 적어준다. md.update(msg.getBytes()); return md.digest();} 1234567891011121314/*** 위와 형태가 비슷하지만 암호화의 결과물로 나온 바이트 타입의 배열을 16진수로 바꾸어 알아보기 힘들게 한다*/public String hasing(String src) throws NoSuchAlgorithmException { MessageDigest md = MessageDigest.getInstance(\"SHA-256\"); md.update(msg.getBytes()); StringBuilder sb = new StringBuilder(); for(byte b : md.digest()){ // 바이트를 2자리의 16진수로 바꾸는데, 남는자리가 생긴다면 0을 추가한다 sb.append(String.format(\"%02x\", b)); } return sb.toString();}","link":"/2020/07/11/java-hasing/"},{"title":"jenkins에서 did 구현하기","text":"12345678910111213141516171819FROM jenkins/jenkins:ltsUSER rootRUN apt-get update &amp;&amp; \\apt-get -y install apt-transport-https \\ ca-certificates \\ curl \\ gnupg2 \\ software-properties-common &amp;&amp; \\curl -fsSL https://download.docker.com/linux/$(. /etc/os-release; echo &quot;$ID&quot;)/gpg &gt; /tmp/dkey; apt-key add /tmp/dkey &amp;&amp; \\add-apt-repository \\ &quot;deb [arch=amd64] https://download.docker.com/linux/$(. /etc/os-release; echo &quot;$ID&quot;) \\ $(lsb_release -cs) \\ stable&quot; &amp;&amp; \\apt-get update &amp;&amp; \\apt-get -y install docker-ceUSER jenkins","link":"/2020/02/17/jenkins-did/"},{"title":"리눅스의 퍼미션과 설정 방법","text":"리눅스 파일 정보 보기리눅스를 기반으로 하는 운영체제에서는 ls(list) 명령어가 있습니다. ls명령어에 -al 옵션을 주어 ls -al 명령어를 이용하면 파일의 해당 디렉토리에 존재하는 파일들의 상세정보를 볼 수 있습니다 drwxr-xr-x 2 root root 4096 Apr 22 16:59 my-file 파일type 퍼미션 링크수 소유자 소유그룹 용량 생성날짜 파일이름 파일 Type d : directory l : 링크 파일 - : 일반 파일 퍼미션 : 해당 파일 or 디렉토리에 어떠한 퍼미션이 부여되어 있는지 표시 링크 수 : 해당 파일이 링크된 수 (링크 : windows운영체제의 바로가기와 같음) 소유자 : 해당 파일의 소유자 이름 소유 그룹 : 해당 파일을 소유한 그룹의 이름. 기본값으로 소유자가 속한 그룹으로 지정된다 용량 : 파일의 용량 생성 날짜 : 파일이 생성된 날짜 파일이름 : 파일의 이름 Permission파일의 권한 등을 설정해, 허가되지 않은 사용자가 읽거나 수정하지 못하도록 한다 퍼미션의 종류 읽기(r : Read) : 읽기권한 쓰기(w : Write) : 쓰기권한 실행(x : eXecute) : 실행권한 퍼미션의 사용자 설정 소유자 : 파일 소유자에 대한 퍼미션 그룹 : 파일의 소유그룹에 대한 퍼미션 공개 : 모든 사용자들에 대한 퍼미션 소유자 - 그룹 - 공개 순으로 rwx가 반복되어 나타난다 즉, rwx가 한묶음로 3개가 나타나며, 이는 각각 소유자, 그룹, 공개에 대한 파일권한이 된다 Permission 변경리눅스에 기반 운영체제에서는 chmod 명령어를 이용해 파일의 permission을 변경할 수 있다 1chmod [변경할 퍼미션의 값] [변경할 파일] 퍼미션의 값은 다음과 같이 나타낸다 읽기(r) : 4 쓰기(w) : 2 실행(x) : 1 제일 오른쪽 자리인 실행 권한 자리부터 2^0, 2^1, 2^2 을 나타낸다 이를 합산하여, 각 사용자에 맞는 권한을 연속해서 적어주면 된다 예를 들어, MyProgram.java를 소유자에 모두 허용( rwx ), 그룹과 공개에는 읽기와 실행만 허용(r-x) 하고싶다면 rwx : 4 + 2 + 1 = 7 r-x : 4 + 0 + 1 = 5 이므로, 소유자-소유 그룹-공개 순으로 755를 권한으로 주면 된다 완성된 명령어는 다음과 같다 1chmod 755 MyProgram.java chmod에는 -R 옵션이 있는데, 해당 옵션은 recursive 즉, 지정한 파일부터 하위 폴더 및 파일까지 모두 권한을 변경하는 옵션이다 파일의 소유자 변경하기소유자 변경은 chown 명령어를 통해 할 수 있다 1chown [변경할 소유자] [변경할 파일] 1chown secondUser MyProgram.java 또한, 소유자에는 소유그룹을 넣어줄 수 도 있다. 1chown anotherUserGroup MyProgram.java 위와같이 명령어를 사용한다면, MyProgram.java의 소유권은 anotherUserGroup의 소유가 된다. Referenceconory님의 블로그","link":"/2020/08/09/linux-permission/"},{"title":"Lombok 플러그인","text":"Lombok자바에서 Model(DTO, VO, Domain) 오브젝트를 만들때, getter/setter 등 반복적으로 만드는 코드를 어노테이션의 선언을 통해 간단하게 해결해주는 라이브러리 MIT 라이센스(MIT LICENSE)를 따른다 Lombok 사용라이브러리 의존성 추가기본적으로 mvn repository 에서 제공하는 사용법을 따르면 편하다 Maven을 사용하는 경우의존성 추가를 위해 다음 내용을 pom.xml에 추가 123456&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.12&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; Gradle을 사용하는 경우build.gradle에 의존성을 추가 1providedCompile group: 'org.projectlombok', name: 'lombok', version: '1.18.12' Model클래스에 어노테이션 선언어노테이션의 종류 @Data : Data어노테이션은 다음의 어노테이션들 모두 포함한다 @ToString : 모든 필드에 대한 toString() 메서드 생성 @EqualsAndHashCode : equals와 hashcode 메서드 생성 @Getter : 모든 필드에 대한 getter생성 @Setter : final로 선언된 필드들에 대하여 setter를 생성 @RequiredArgsConstructor : final로 선언된 필드를 인자로 갖는 생성자를 생성한다 @NoArgsConstructor : 기본 생성자(인자를 갖지 않는) 생성 @AllArgsConstructor : 모든 필드를 인자로 갖는 생성자 생성 @builder : 객체의 생성을 도와주는 메서드를 생성 Builder 어노테이션 사용법 @NonNull : 객체 생성시 해당 필드의 null체크를 한다. 해당 필드가 null로 넘어오면, NullPointerException 예외를 발생시킨다 Builder 어노테이션의 사용법1234567// Model class@Builderpublic class Member{ private int id; private String name; private String password;} 위와 같이 선언된 모델클래스의 객체를 생성할 때, 1234567891011121314public class MemberController{ // another methods ... @GetMapping public void createMember(@RequestBody MemberDTO dto){ Member member = Member.builder() .id(dto.getId()) .name(dto.getName()) .password(dto.getPassword()) .build(); } // another methods ...} ReferencesProject Lombok 공식 홈페이지 갓대희님의 티스토리 블로그","link":"/2020/08/10/lombok/"},{"title":"병합정렬(MergeSort)","text":"개념분할 정복 기법을 사용한 정렬 알고리즘 항상 O ( n lg n ) 시간을 소요 비고 소요 시간 Worst O(n lg n) Average O(n lg n) Best O(n lg n) Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * Merge Sort * 분할 정복 기법을 이용하는 정렬 방법 * 최악, 최선, 평균시간 모두 O(n log n) 시간 */public class MergeSort { // 임시 배열 static int[] tmp; public static void merge(int[] arr, int start, int mid, int end) { // 분할된 배열을 정렬하기위한 임시변수 int left = start; int right = mid + 1; // 임시배열의 인덱스를 기억할 변수 int tmpidx = start; // mid를 기준으로 좌 or 우측 배열 중 하나가 완료될때까지 반복문 수행 while (left &lt;= mid &amp;&amp; right &lt;= end) { if (arr[left] &lt;= arr[right]) { tmp[tmpidx++] = arr[left++]; } else { tmp[tmpidx++] = arr[right++]; } } // 위에서 정렬되지 않은 값들을 정렬 // 위에서 한쪽이 완료되었으므로, 나머지 한쪽을 정렬한다 if (left &lt;= mid) { while (left &lt;= mid) { tmp[tmpidx++] = arr[left++]; } } else if (right &lt;= end) { while (right &lt;= end) { tmp[tmpidx++] = arr[right++]; } } // 임시배열에 저장된 정렬된 값들을 원래 배열에 덮어쓴다 for (int i = start; i &lt; end; i++) { arr[i] = tmp[i]; } } public static void devide(int[] arr, int start, int end) { // start가 end보다 작거나 같다면 정렬할 요소는 1개 남은것을 뜻한다 // 요소가 2개 이상일때마 정렬을 수행한다 if (start &lt; end) { int mid = (start + end) / 2; devide(arr, start, mid); devide(arr, mid + 1, end); merge(arr, start, mid, end); } } public static void main(String[] args) throws Exception { int[] arr = { 1, 3, 5, 7, 9, 2, 4, 6, 8, 10 }; tmp = new int[arr.length]; System.out.println(\"====정렬 전====\"); System.out.println(Arrays.toString(arr)); devide(arr, 0, arr.length - 1); System.out.println(\"====정렬 후====\"); System.out.println(Arrays.toString(arr)); }} 결과12345// 결과====정렬 전====[1, 3, 5, 7, 9, 2, 4, 6, 8, 10]====정렬 후====[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]","link":"/2020/03/16/mergesort/"},{"title":"MVC, MVP, MVVM 패턴","text":"MVC기존의 all-in-one 방식의 문제점인, 프로젝트 규모가 커지거나 잦은 업무변경 발생시 어려워지는 유지보수를 개선하기 위해 제안된 방식 Model, View, Controller의 3가지 컴포넌트로 역할을 나누어 프로그램을 구성한다 MVC 패턴의 이점 높은 재사용성 look and feel 을 쉽게 교체할 수 있다. one source multi use를 구현할 수 있다. 코드를 재사용할 수 있다. 빠른 개발, 저렴한 비용 다른 프로젝트에서도 모델 컴포넌트를 재사용할 수 있어 개발 속도가 빨라진다 소스 코드를 역할에 따라 여러 컴포넌트로 쪼개게 되면 전체적인 개발 유지보수 비용을 줄일 수 있다. Model Database와 연동하여 사용자가 입력한 데이터나 사용자에게 출력할 데이터를 다루는 일을 한다.(트랜잭션을 다루는 일) View 모델이 처리한 데이터나 그 작업의 결과를 갖고 사용자에게 출력할 화면을 만드는 일을 한다. Controller 클라이언트의 요청을 받았을 때 그 요청에 대해 실제 업무를 수행하는 모델 컴포넌트를 호출한다. 또한, 클라이언트가 보낸 데이터가 있다면, 모델을 호출하기 전 데이터를 적절히 가공하는 역할을 한다 특징사용자의 입력(Action)이 Controller를 통해 들어온다Controller는 여러개의 View를 선택할 수 있는 1:N 구조Controller는 View를 선택할 뿐 직접 업데이트 하지 않는다 (View는 컨트롤러를 알지 못한다) MVPModel, View, Presenter로 구성MVC패턴에서 Controller대신 Presenter가 존재 Presenter? View에서 요청한 정보로 Model을 가공하여 View에 전달해 주는 부분. View와 Model을 이어주는 컴포넌트라고 생각하면 될 듯 하다 Presenter가 Model과 View의 중간에서 다리역할을 하여, 요청을 받고, 데이터를 요청하며, 데이터를 가공하고 가공한 데이터를 View에 보내줌 장점View와 Model의 의존성이 사라진다. 단점Presenter와 View가 높은 의존성을 갖게된다 MVVMModel, View, View Model로 구성된 디자인 패턴 View Model View를 표현하기 위해 만든 View를 위한 Model. View를 나타내 주기 위한 Model이자 View를 나타내기 위해 데이터를 처리하는 부분 특징Command패턴과 DataBinding 두가지 패턴을 사용하여 구현됨위의 두가지 요소를 이용해 View와 ViewModel 사이의 의존성을 없앴다View Model과 View는 1:N 관계이다 장점View와 Model사이의 의존성이 사라짐. 또한 Command패턴과 Data Binding을 사용하여 View Model 사이의 의존성 또한 없앤 디자인 패턴. 각 부분이 독립적이기에 모듈화하여 개발할 수 있다 단점View Model의 설계가 쉽지 않다","link":"/2020/05/04/mvc-mvp-mvvm-pattern/"},{"title":"MySQL Unable to laod authentication plugin &#39;caching_sha2_password&#39; 에러","text":"MySQL 8.x는 인증플러그인으로 caching_sha2_password를 default로 사용하고 이전 버전인 MySQL 5.x는 mysql_native_password 방식을 default로 사용한다 기본적인 인증플러그인의 방식때문에 8버전 이용시 MYSQL unable to laod authentication plugin 'caching_sah2_password' 에러가 발생하기도 한다 Solution 사용자에 대해서 password 방식을 5.x 버전에서 사용하던 방식으로 바꾼다 1mysql&gt; ALTER USER 'root'@'$' IDENTIFIED WITH mysql_native_password BY 'password'; MySQL의 설정파일인 my.cnf 또는 my.ini 수정 default_authentication_plugin=caching_sha2_password 부분을 default_authentication_plugin=mysql_native_password 로 수정하고 재부팅","link":"/2020/03/17/mysql-authentication-error/"},{"title":"Next Permutation","text":"개요 어떠한 수열이 주어지고, 이 수열에 대한 순열을 모두 뽑아 오름차순으로 나열했을 때, 항상 다음 순열(다음 크기의 순열)만 뽑아내는 함수 장점 재귀로 순열을 구하는 것보다 소요시간이 적다. 주의할 점 순열의 현재상태가 주어졌을때 무조건 다음크기의 순열만 나오기 때문에, 처음부터 모든 순열을 구하기 위해서는 수열을 오름차순 정렬을 한 배열을 초기값으로 지정해주어야 한다 예시 처음 수열이 [1,2,3]일 때, 다음 크기의 순열 [1,3,2]가 리턴되는 함수 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class Next_Permutation { int[] array; Next_Permutation(int[] arr) { this.array = arr; } // 현재 갖고있는 순열의 다음순열이 있는지 여부를 리턴 // 순열이 내림차순 정렬이 되어있는것과 같다면 다음 순열은 없는것과 같다 public boolean hasNext() { for (int i = 0; i &lt; array.length - 1; i++) { if (array[i] &lt; array[i + 1]) { return false; } } return true; } // 다음 순열 즉, 순열을 오름차순으로 정렬했을때 다음에 오는 순열을 리턴한다 // 꼭대기 찾기 : 수열의 뒤에서부터 시작할 때, 현재 인덱스의 앞자리가 줄어드는 인덱스, next permutation의 기준점이 된다. 꼭대기 인덱스 -1 과 array[꼭대기-1]보다 큰 수를 스왑 // topidx ~ array.length-1 까지 스왑 함수를 이용해 반전 시킨다 // swap(topidx, array.length-1) public int[] getNext() { int arrlen = array.length; int topidx = arrlen - 1; for (int i = arrlen - 1; i &gt; 0; i--) { if (array[i - 1] &gt; array[i]) { topidx = i - 1; } else { break; } } int tmpidx = array.length - 1; for (int i = array.length - 1; i &gt; topidx; i--) { if (array[topidx - 1] &lt; array[i]) { tmpidx = i; } } this.swap(array, topidx - 1, tmpidx); int bidx = topidx, aidx = array.length - 1; while (bidx &lt; aidx) { this.swap(array, bidx, aidx); bidx++; aidx--; } return this.array; } private void swap(int[] arr, int idx, int idx2) { int tmp = arr[idx]; arr[idx] = arr[idx2]; arr[idx2] = tmp; }}","link":"/2020/03/03/next-permutation/"},{"title":"spring-boot-value-annotation","text":"스프링에는 개발에 도움이되는 많은 어노테이션이 있습니다. 그중 오늘은 @Value 어노테이션에 대해 알아보도록 하겠습니다 Value spring에서 application.properties에 작성된 값을 자바의 변수에 매핑해주는 어노테이션으로 요청을 하는 서버의 URL등을 설정해두고 변수에 매핑을 해서 사용한다 장점application.properties의 값만 바꾸면 되니, 많은 값들을 한번에 바꿀 수 있어 유지보수에 용이하다 사용법값을 할당하고 싶은 변수의 바로 상단에 @Value(“${}”)를 선언하고중괄호 안에 key값을 적어주면 된다 1234// in application.properties// key = value 형태my.custom.url=http://my.url.comcustom.local.path=classpath:/static/ 123456789101112131415class something{ // requestURL변수에 my.custom.url을 키로하는 값인 http://my.url.com이 할당된다 @Value(\"${my.custom.url}\") String requestURL; @Value(\"${custom.local.path}\") String local_file_path; public void someMthod(){ String url = requestURL; // classpath/static 을 경로로하는 파일객체 생성 File newFile = new File(local_file_path); // ... }}","link":"/2020/05/04/spring-boot-value-annotation/"},{"title":"Spring Cache","text":"cache?컴퓨터과학에서 데이터나 값을 미리 복사해 놓는 임시 저장소를 가리킨다캐시는 캐시의 접근 시간에 비해 원래 데이터를 접근하는 시간이 오래 걸리는 경우나 값을 다시 계산하는 시간을 절약하고 싶은 경우에 사용한다캐시(위키백과) 자주 사용하는 데이터 or 자주 접근하는 데이터를 메모리상에 저장해두고, 필요할때마다 데이터베이스에 접근하여 데이터를 가져오는 것이 아닌, 메모리에서 바로 불러오는 기술을 뜻한다. Springboot 프로젝트에 Cache 적용하기 “Spring-boot-starter-cache” 라이브러리 의존성을 추가한다 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt; 1compile group: 'org.springframework.boot', name: 'spring-boot-starter-cache' 캐시 기능을 사용하고싶은 프로젝트에 @EnableCaching 어노테이션을 선언한다 1234567@EnableCaching@SpringBootApplicationpublic class DemoApplication { public static void main(String[] args){ SpringApplication.run(DemoApplication.class, args); }} 캐시를 적용하고싶은 메서드에 @Cacheable 어노테이션을 선언 12345// 전체상품의 리스트를 가져오는 메서드@Cacheable(value=\"products\")public ResponseEntity&lt;String, Object&gt; getProductList(){ // ...} 캐시 설정 어노테이션 어노테이션 설명 @Cacheable 메소드에 캐시 트리거 설정 @CachePut 메소드 실행과 방해없이 캐시 갱신 @CacheEvict 캐시되있는 데이터 지우기 @CacheConfig 캐시 관련 설정 @EnableCache 스프링 캐시 활성화 캐시 어노테이션들의 속성 어노테이션 설명 value 캐시의 이름 key 캐시할 키를 설정(기본설정하지 않으면 파라미터로 설정) condition 특정 조건에 따라 캐시를 할지 않을지 결정 cacheManager 해당 캐시 매니저를 이용해 캐시를 사용 Cache Manager의 종류 ConcurrentMapCacheManager (default) : 캐시매니저를 선언하지 않으면 기본값으로 작동 Ehcache : 실 서비스하는 제품에서 많이 사용한다 redis : 사용하려면 spring-boot-starter-data-redis를 의존성추가 해주어야한다 캐시 테스트JMeter를 이용하여 api의 응답시간 속도차를 비교한다100개의 스레드를 이용해 부하를 주어 테스트를 하였다. 캐시 적용 전 캐시 적용 후 캐시 적용전 스레드가 많아질수록 응답시간은 길어져 최대 약 3300ms까지 응답시간이 증가하였다.하지만, 캐시 적용후에는 최대 약 330ms로 90% 감소함을 알 수 있으며, 불러오는 데이터으 양이 많고, API요청이 많을수록 성능폭은 크게 차이날 것으로 예상된다. 캐시 사용시 주의할 점 계획없이 캐시를 적용하면 오히려 성능이 떨어질 수 있다 캐시는 메모리에 데이터를 저장해뒀다 필요할 때 가져오는 방법이기에, 데이터의 양 대비 메모리의 용량이 작다면 시스템의 성능저하를 일으킬 수 있다. ReferenceSpring Cache 공식 문서Wan 님의 블로그","link":"/2020/03/30/spring-cache/"},{"title":"spring 의존성 주입 방식","text":"필드 주입@Autowired를 이용한 의존성 주입 방식의존성을 갖는 변수를 선언하고 해당 변수의 위에 @Autowired 어노테이션을 선언한다 12345678@Componentpublic class MemberService{ @Autowired private MemberRepository repository; // do something ...} Setter1234&lt;!-- root-context.xml --&gt;&lt;bean&gt; &lt;property name=\"\" ref=\"\"/&gt;&lt;/bean&gt; 또는 코드 내에서 setter 메서드 위에 @Autowired 어노테이션을 선언한다 1234567891011@Componentpublic class MemberService{ private MemberRepository repository; @Autowired public void setMemberRepository (MemberRepository memberRepository){ this.repository = memberRepository; } // do something} 생성자1234&lt;!-- root-context.xml --&gt;&lt;bean&gt; &lt;constructor-arg ref=\"\"&lt;/bean&gt; 123456789@Componentpublic class MemberService{ private MemberRepository repository; @Autowired public MemberService(MemberRepository memberRepository){ this.repository = memberRepository; }} Lombok을 이용한 생성자 주입 방법Lombok라이브러리는 객체를 나타내는 클래스에서 자주 사용한 getter와 setter, toString 등을 어노테이션의 선언만으로 간단하게 사용할 수 있게 해주는 라이브러리이다.Lombok에서 제공하는 어노테이션 중 @AllArgsConstructor어노테이션이 있는데, 이 어노테이션은 클래스의 멤버 변수를 모두 이용하여 생성자를 만들어 준다. 12345678@Service@AllArgsConstructorpublic class MemberService{ private MemberRepository repository; private Hashing hashing; // 사용자의 패스워드를 해시값으로 변환시키기 위한 클래스 // do something} 이와 같이 작성하면 직접 생성자를 작성해주지 않아도, Lombok라이브러리가 생성자를 작성해주기 때문에 조금 더 쉽게, 생성자를 통한 의존성 주입이 가능하다. Spring 4.3 부터는 생성자가 하나이고, 의존성이 있는 클래스가 빈으로 등록되어 있으면 생성자를 이용한 의존성 주입에서 @Autowired 어노테이션의 생략이 가능하다 어떤 방법을 써야할까??스프링 프레임워크의 공식문서에서는 생성자를 통한 의존성 주입을 권장하고 있다.이유는 생성자를 통한 의존성 주입을 할 때, 필수적으로 사용해야하는 의존성 없이는 인스턴스를 만들지 못하도록 강제할 수 있기 때문이다 예를 들어, MemberService가 MemberRepository 없이 제대로 동작할 수 없다면, MemberService 객체입장에서 MemberRepository의 객체는 반드시 있어야 하는 객체이다이를 강제할 수 있는 방법이 생성자를 통한 의존성 주입인 것이다. 필드, setter 주입 방법의 필요성순환 참조 시에 사용할 수 있다. 두개의 클래스가 각자를 참조하고 있는데 생성자를 통한 주입을 이용하게 되면, 둘 중 어떤 클래스의 객체도 만들어지지 않게되고, App은 실행조차 되지 않는다.순환참조는 피하는게 좋지만, 어쩔 수 없는 상황이면 Setter나 필드 주입방법을 사용하면 되겠다.","link":"/2020/06/16/spring-ioc/"},{"title":"Spring의 Restcontroller","text":"Spring 사용 중 실수로 발생했던 에러SSAFY 동기들과 프로젝트를 진행 중 테스트를 상황에서 생겼던 에러입니다 분명 제대로 작성한 코드같았으나, postman을 이용하거나 크롬등의 웹 브라우저를 이용하여도 예상된 응답인 “test api”가 오지 않고계속해서 “404 NotFound” 에러만 발생하였습니다 문제의 코드는 다음과 같습니다 12345678@RestController(\"/api\")public class MyController{ @GetMapping(\"/test\") public String test(){ return \"test api\"; }} 여러 부분을 고쳐가며 진행한 결과 다음의 코드로 에러를 해결할 수 있었습니다 123456789@RestController@RequestMapping(\"/api\")public class MyController(){ @GetMapping(\"/test\") public String test(){ return \"test api\"; }} @RestController 어노테이션 밑에 @RequestMapping 어노테이션을 추가해주었습니다즉, @RestController 어노테이션은 주소 매핑 기능이 없어 /api라는 주소 자체가 매핑이 되어있지 않았으며,이로인해 아무리 알맞는 주소를 입력하여도 404 NotFound에러가 발생한 것입니다. 연속된 프로젝트로 인해 자신감있게 작성한 코드에 문제가 생긴것을 보고 더 많은 연습이 필요함을 느꼈습니다","link":"/2020/05/17/spring-restcontroller/"},{"title":"Spring Boot 설정 Profile","text":"Spring Boot 설정 ProfileSpring 프로젝트를 개발할 때, 설정파일을 다르게 해서 개발을 해야할 때가 있다. 예를 들어, 로컬의 개발환경과 production 개발환경에서의 설정파일이다. application.properties 파일을 이용해 설정파일을 바꿀 때 application-{profile}.properties 형식으로 여러개의 properteis 파일을 생성한다 123application-default.propertiesapplication-dev.propertiesapplication-deploy.properties yaml파일을 이용할 때123456789101112131415161718192021spring: profiles: active: default # 기본환경 선택# default 설정---spring: profiles: default# other config ...# dev 설정---spring: profiles: dev# other config ...# deploy 설정---spring: profiles: deploy# other config ... ---를 기준으로 값들이 구분된다 특정 설정파일을 이용하는 Spring 프로젝트 실행1java -jar -Dspring.profiles.active=default app.jar default의 위치에 각각 위에서 설정해준 default, dev, deploy등을 적어넣어주면 된다 profiles를 설정하지 않으면 default가 기본으로 동작한다","link":"/2020/03/15/spring-separate-properties/"},{"title":"spring-swagger2","text":"Swagger?스프링 프레임워크 상에 작성한 API를 쉽게 문서화 시켜주는 라이브러리 입니다. Swagger의 사용Swagger 설정Swagger를 사용하기 위해서는 먼저 swagger 라이브러리를 추가해주어야 합니다. 본인의 프로젝트 설정에 맞춰 등록하시면 됩니다. mvn repository에 들어가서 해당하는 라이브러를 찾습니다. springfox swagger2 springfox swagger-ui 12345// build.gradle// springfox-swager2compile group: 'io.springfox', name: 'springfox-swagger2', version: '3.0.0'// springfox-swager-uicompile group: 'io.springfox', name: 'springfox-swagger-ui', version: '3.0.0' 12345678910111213&lt;!-- pom.xml--&gt;&lt;!-- springfox-swagger2--&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- springfox-swager-ui--&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt; 의존성을 추가하였으면 Swagger 라이브러리의 설정을 위한 클래스를 생성합니다 설정 클래스에 들어가야될 필수 어노테이션으로 @Configuration과 @EnableSwagger2이 필요합니다 12345@Configuration@EnableSwagger2public class SwaggerConfig{ // ...} 이 후, 2개의 메서드를 작성해주어야 합니다. ApiInfo 타입을 반환하는 apiInfo() 메서드 Docket 타입을 반환하는 api() 메서드 123456789101112131415161718192021@Configuration@EnableSwagger2public class SwaggerConfig{ private ApiInfo apiInfo(){ return new ApiInfoBuilder() .title(\"API의 타이틀 정보\") .version(\"API 버전 정보\") .description(\"API에 대한 설명\") .build(); } public Docket api(){ return new Docket(DocumentationType.SWAGGER_2) .grouName(\"My-Group\") .apiInfo(apiInfo()) // 위에서 작성한 apiInfo 메서드의 리턴값을 사용 .select() .apis(RequestHandlerSelectors.basePackage(\"com.example.board.Controller\")) .paths(PatheSelectors.any()) .build(); }} apiInfo 메서드에서 반환하는 값은, Swagger에서 메인으로 보여질 정보를 설정한 객체를 반환합니다. api 메서드에서는 api 그룹 이름 이동 경로 보여질 api 등이 설정됩니다 Swagger는 설정 클래스만 만든다고 완성이 되는 것이 아니라, 작성한 api 클래스에서 swagger를 적용하겠다는 어노테이션을 작성해주어야 합니다. 어노테이션의 이름은 @ApiOperation()으로 괄호에 속성값들이 들어가게 됩니다. 123456// Some Controller@GETMappingi(\"/board\")@ApiOperation(value = \"간단한 설명을 적어줍니다\", response = BoardDTO.class)public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; getBoardList(){ // get boardlist} @ApiOperation()어노테이션을 swagger에서 보여줄 api에 작성해주면 사용하기 위한 설정은 끝이 납니다. 기본적으로 속성은 value : 해당 메서드(api 호출시 반응하는)에 대한 간단한 설명 response : 성공적으로 메서드가 작동 시 반환하는 클래스의 타입 두가지는 적어주는 것이 좋습니다. vlaue 옵션 적용 결과 reponse 옵션 적용 결과 위의 이미지는 value 속성을 설정해주었을 때, 아래 이미지는 reponse 속성을 설정해주었을 때 이미지와 같이 보이게 됩니다 Swagger 페이지 접속 http://ip주소/swagger-ui.html 위의 주소로 접속하면 위에서 설정한 값들이 보이게 됩니다 swagger는 보이는 것 뿐만 아니라, 클릭으로 기능이 제대로 작동하는지 까지 테스트 할 수 있습니다.","link":"/2020/08/16/spring-swagger2/"},{"title":"마크다운 문서 내부에 링크 적용하기","text":"마크다운 문서를 이용하면서 외부링크를 연결하는것이 아닌, 문서 내부의 특정 헤더에 연결을 하고싶은 경우가 있다. 마크다운 문서 내부의 헤드에 링크를 연결하고 싶은경우는 다음과 같이 사용하면 된다 1[보여지는 내용](#연결할-헤드의-내용) 예시는 다음과 같다 123456[띄어쓰기는 '-'로](#마크다운-내부에서-헤드-링크)[영어는 소문자로](#use-link-in-markdown-document)## 마크다운 내부에서 헤드 링크#### Use link in Markdown document 예시와 같이, 띄어쓰기는 ‘-‘로 대치를 하고, 영문의 경우엔 전부 소문자를 써야한다또한 몇단계의 헤드던 링크는 헤더의 레벨에 상관 없이 하나의 #만 사용하여 링크를 건다 결과물은 아래와 같이 나오게된다 띄어쓰기는 ‘-‘로 영어는 소문자로 마크다운 내부에서 헤드 링크 Use link in Markdown document NOTICE현재, 프레임 워크 또는 테마의 문제로 마지막 헤드에는 링크가 걸리지 않는 문제가 있습니다.","link":"/2020/08/11/use-headlink-in-markdown/"}],"tags":[{"name":"server","slug":"server","link":"/tags/server/"},{"name":"network","slug":"network","link":"/tags/network/"},{"name":"spring boot","slug":"spring-boot","link":"/tags/spring-boot/"},{"name":"spring","slug":"spring","link":"/tags/spring/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"Back-end","slug":"Back-end","link":"/tags/Back-end/"},{"name":"bean","slug":"bean","link":"/tags/bean/"},{"name":"component","slug":"component","link":"/tags/component/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"Authenticate","slug":"Authenticate","link":"/tags/Authenticate/"},{"name":"JWT","slug":"JWT","link":"/tags/JWT/"},{"name":"login","slug":"login","link":"/tags/login/"},{"name":"profile","slug":"profile","link":"/tags/profile/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"Event Bus","slug":"Event-Bus","link":"/tags/Event-Bus/"},{"name":"vue-cli","slug":"vue-cli","link":"/tags/vue-cli/"},{"name":"intellij","slug":"intellij","link":"/tags/intellij/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"permutation","slug":"permutation","link":"/tags/permutation/"},{"name":"combination","slug":"combination","link":"/tags/combination/"},{"name":"swap","slug":"swap","link":"/tags/swap/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"Dockerfile","slug":"Dockerfile","link":"/tags/Dockerfile/"},{"name":"hash","slug":"hash","link":"/tags/hash/"},{"name":"encrypt","slug":"encrypt","link":"/tags/encrypt/"},{"name":"CI&#x2F;CD","slug":"CI-CD","link":"/tags/CI-CD/"},{"name":"Jenkins","slug":"Jenkins","link":"/tags/Jenkins/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"permission","slug":"permission","link":"/tags/permission/"},{"name":"sort","slug":"sort","link":"/tags/sort/"},{"name":"mergesort","slug":"mergesort","link":"/tags/mergesort/"},{"name":"design pattern","slug":"design-pattern","link":"/tags/design-pattern/"},{"name":"pattern","slug":"pattern","link":"/tags/pattern/"},{"name":"software engineering","slug":"software-engineering","link":"/tags/software-engineering/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"db","slug":"db","link":"/tags/db/"},{"name":"error","slug":"error","link":"/tags/error/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Permutation","slug":"Permutation","link":"/tags/Permutation/"},{"name":"springboot","slug":"springboot","link":"/tags/springboot/"},{"name":"cache","slug":"cache","link":"/tags/cache/"},{"name":"swagger","slug":"swagger","link":"/tags/swagger/"},{"name":"swagger-ui","slug":"swagger-ui","link":"/tags/swagger-ui/"},{"name":"api","slug":"api","link":"/tags/api/"},{"name":"documentation","slug":"documentation","link":"/tags/documentation/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"headlink","slug":"headlink","link":"/tags/headlink/"},{"name":"link","slug":"link","link":"/tags/link/"},{"name":"usage","slug":"usage","link":"/tags/usage/"}],"categories":[{"name":"spring","slug":"spring","link":"/categories/spring/"},{"name":"java","slug":"java","link":"/categories/java/"},{"name":"server","slug":"spring/server","link":"/categories/spring/server/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"},{"name":"server","slug":"server","link":"/categories/server/"},{"name":"server","slug":"java/server","link":"/categories/java/server/"},{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"},{"name":"Server","slug":"Server","link":"/categories/Server/"},{"name":"Docker","slug":"Docker","link":"/categories/Docker/"},{"name":"os","slug":"os","link":"/categories/os/"},{"name":"infra","slug":"server/infra","link":"/categories/server/infra/"},{"name":"design pattern","slug":"design-pattern","link":"/categories/design-pattern/"},{"name":"db","slug":"db","link":"/categories/db/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"java","slug":"algorithm/java","link":"/categories/algorithm/java/"},{"name":"Docker","slug":"Server/Docker","link":"/categories/Server/Docker/"},{"name":"errorlog","slug":"errorlog","link":"/categories/errorlog/"},{"name":"운영체제","slug":"os/운영체제","link":"/categories/os/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/"},{"name":"mysql","slug":"db/mysql","link":"/categories/db/mysql/"},{"name":"CI&#x2F;CD","slug":"Server/Docker/CI-CD","link":"/categories/Server/Docker/CI-CD/"},{"name":"markdown","slug":"markdown","link":"/categories/markdown/"}]}